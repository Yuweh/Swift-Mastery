//: Playground - noun: a place where people can play

import UIKit

//CodeCamp 2018: OOP Exercises

//MARK: MUSIC Class = Music class that encapsulates an array of notes and allows you to flatten it into a string with the prepared() method.
class Music {
    let notes: [String]
    
    init(notes: [String]) {
        self.notes = notes
    }
    
    func prepared() -> String {
        return notes.joined(separator: " ")
    }
}

/* MARK: BASE CLASS - This is the root class of the instruments hierarchy.
 It defines a blueprint which forms the basis of any kind of instrument. */
class Instrument {
    //PROPERTIES
    // 2 Instrument’s stored properties (data) that all instruments have. In this case, it’s just the brand, which you represent as a String.
    let brand: String
    // 3 Its purpose is to construct new instruments by initializing all stored properties.
    init(brand: String) {
        //4 instrument’s brand stored property to what was passed in as a parameter.
        self.brand = brand
    }
    
    //MARK: METHOD - Functions defined inside a class are called methods because they have access to properties, such as brand in the case of Instrument.
    
    /*The tune() method is a placeholder function that crashes at runtime if you call it. Classes with methods like this are said to be abstract because they are not intended for direct use. Instead, you must define a subclass that overrides the method to do something sensible instead of only calling fatalError(). */
    
    func tune() -> String {
        fatalError("Implement this method for \(brand)")
    }
    
    func play(_ music: Music) -> String {
        return music.prepared()
    }
    
    func perform(_ music: Music) {
        print(tune())
        print(play(music))
    }
    
}

//MARK: INHERITANCE

/* 1 Piano class as a subclass of the Instrument parent class.
All the stored properties and methods are automatically inherited by the Piano child class and available for use. */

class Piano: Instrument {
    let hasPedals: Bool
    
    /* 2 All pianos have exactly the same number of white and black keys regardless of their brand.
     The associated values of their corresponding properties don’t change dynamically,
     so you mark the properties as static in order to reflect this.
     */
    static let whiteKeys = 52
    static let blackKeys = 36
    
    /*  3 The initializer provides a default value for its hasPedals parameter which allows you to leave it off if you want. */
    init(brand: String, hasPedals: Bool = false) {
        self.hasPedals = hasPedals
        /* 4 use the super keyword to call the parent class initializer
          The super class initializer takes care of initializing inherited properties — in this case, brand. */
        super.init(brand: brand)
    }
    
    /* 5 override the inherited tune() method’s implementation with the override keyword.
     This provides an implementation of tune() that doesn’t call fatalError(), but rather does something specific to Piano.*/
    override func tune() -> String {
        return "Piano standard tuning for \(brand)."
    }
    
    //*REPLACED by an overloaded method below:
//    override func play(_ music: Music) -> String {
//        /* 6 override the inherited play(_:) method. And inside this method,
//         you use the super keyword this time to call the Instrument parent method
//         in order to get the music’s prepared notes and then play on the piano. */
//        let preparedNotes = super.play(music)
//        return "Piano playing \(preparedNotes)"
//    }
    
    override func play(_ music: Music) -> String {
        return play(music, usingPedals: hasPedals)
    }
    
    func play(_ music: Music, usingPedals: Bool) -> String {
        let preparedNotes = super.play(music)
        if hasPedals && usingPedals {
            return "Play piano notes \(preparedNotes) with pedals."
        }
        else {
            return "Play piano notes \(preparedNotes) without pedals."
        }
    }

}

//MARK: Instances

// 1
let piano = Piano(brand: "Yamaha", hasPedals: true)
piano.tune()
// 2
let music = Music(notes: ["C", "G", "F"])
piano.play(music, usingPedals: false)
// 3
piano.play(music)
// 4
Piano.whiteKeys
Piano.blackKeys




